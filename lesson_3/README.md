# 第3回宿題
## 宿題1
>モジュール化されたプログラムを変更して、「*」「/」に対応しよう 

**構成**  
式を2段階で評価 
1. 1回目の評価で「*」「/」を処理 e
2. 2回目の評価で「+」「-」を処理

**コメント**
{'type':'MULTIPLY'}
じゃなくて、変数TYPE_MULTIPLYとした方が、同じ変数何回も書かなくてよい
## 宿題2
>書いたプログラムが正しく動いていることを確認するためのテストケースを追加しよう
- 掛け算ができるか
- 割り算ができるか
- 掛け算(割り算)を後ろに書いても、掛け算(割り算)から計算してくれるか
- 掛け算割り算が複数あっても対応できるか
- 掛け算と割り算連続でできるか
- 小数を含む掛け算割り算ができるか

上記を確認するため、以下のテストケースをつくった。
```
test("4+2*5") # 掛け算ができるか。掛け算を後ろに書いても掛け算から計算してくれるか。
test("4/2*1+2") # 割り算ができるか。掛け算と割り算複数できるか。連続でできるか。
test("5.2+3*5.4+1") # 小数を含む掛け算割り算ができるか
```

**コメント**
0を含んだ計算式を書いてほしい
## 宿題3
>括弧に対応しよう

括弧内を先に計算するために、括弧内の数式を切り出して、その値を求める関数、evaluate_bracketをevaluate関数の最初に呼び出した。

**evaluate_bracketの構成**
1. 入力の数式*line*を頭から見ていき、左括弧"("がでてきたら、その括弧がどこで閉じるか探す。bracket_countという変数を用いることで、括弧のネスト構造にも対応できる。
2. 括弧内を*part_line*として切り出し、*part_line*の計算結果を、evaluate関数の再帰呼び出しで求める。
3. token上で、括弧内の数式を、計算結果の値に書き換える

**コメント**
read_bra(),read_cket()という命名より、read_bracket_start(),read_cket_end()などの命名方式が良い。
内側のカッコ
キューでやるとよい。
木構造でもよい。
()の中に()が入るテストケースが漏れている
## 宿題4
>abs(), int(), round() に対応しよう

abs(), int(), round()を計算する関数をformat_numberとする。
evaluate_bracketで括弧を処理したあとに呼び出すことで、シンプルになる。

**コメント**
index += 3　みたいなのは、"3"が手入力になっている。
TYPE_ABS = ‘abs’
index + len(TYPE_ABS)
のような書き方にしておくことで、abs関数の名前がabscなどになっても自動的に変更される。

